/*
 * Event Stream Model (ESM): Push model for input events.
 * Currently only works for certain mouse events.
 *
 * Dustin Colten McAfee <dmcafee2@my.utk.edu> <dustin.mcafee@my.maryvillecollege.edu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 */

#include <linux/input.h>
#include <linux/sched.h>
#include <linux/pid.h>
#include <linux/types.h>
#include <linux/slab.h>
#include <linux/linkage.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/uaccess.h> //copy_from_user

#include <ESM.h>
//#include <linux/syscalls.h>

application_l mouse_rel_x_handlers = {
	.list = LIST_HEAD_INIT(mouse_rel_x_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_rel_y_handlers = {
	.list = LIST_HEAD_INIT(mouse_rel_y_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_rel_wheel_handlers = {
	.list = LIST_HEAD_INIT(mouse_rel_wheel_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_rel_hwheel_handlers = {
	.list = LIST_HEAD_INIT(mouse_rel_hwheel_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_btn_left_handlers = {
	.list = LIST_HEAD_INIT(mouse_btn_left_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_btn_right_handlers = {
	.list = LIST_HEAD_INIT(mouse_btn_right_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l mouse_btn_middle_handlers = {
	.list = LIST_HEAD_INIT(mouse_btn_middle_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};
application_l no_handlers = {
	.list = LIST_HEAD_INIT(no_handlers.list),
	.event_handler = NULL,
	.event_keycode = APPLICATION_LIST_SIZE
};

application_list_t application_list = {
	.mouse_rel_x_handlers = &mouse_rel_x_handlers,
	.mouse_rel_y_handlers = &mouse_rel_y_handlers,
	.mouse_rel_wheel_handlers = &mouse_rel_wheel_handlers,
	.mouse_rel_hwheel_handlers = &mouse_rel_hwheel_handlers,
	.mouse_btn_left_handlers = &mouse_btn_left_handlers,
	.mouse_btn_right_handlers = &mouse_btn_right_handlers,
	.mouse_btn_middle_handlers = &mouse_btn_middle_handlers,
	.no_handlers = &no_handlers
};

application_l* handlers_for_event(esm_event_t keycode){
	application_l* application;
	switch (keycode){
	case MOUSE_RELATIVE_X:
		application = application_list.mouse_rel_x_handlers;
		break;
	case MOUSE_RELATIVE_Y:
		application = application_list.mouse_rel_y_handlers;
		break;
	case MOUSE_RELATIVE_WHEEL:
		application = application_list.mouse_rel_wheel_handlers;
		break;
	case MOUSE_RELATIVE_HWHEEL:
		application = application_list.mouse_rel_hwheel_handlers;
		break;
	case MOUSE_BUTTON_LEFT:
		application = application_list.mouse_btn_left_handlers;
		break;
	case MOUSE_BUTTON_RIGHT:
		application = application_list.mouse_btn_right_handlers;
		break;
	case MOUSE_BUTTON_MIDDLE:
		application = application_list.mouse_btn_middle_handlers;
		break;
	default:
		application = application_list.no_handlers;
		break;
	}
	return application;
}

//esm_event_t esm_keycode_from_input(struct input_value* event){
esm_event_t esm_keycode_from_input(__u16 type, __u16 code){
        esm_event_t event_keycode = APPLICATION_LIST_SIZE;
        if(type == EV_REL){
                switch (code) {
                case REL_X:
                        event_keycode = MOUSE_RELATIVE_X;
                        break;
                case REL_Y:
                        event_keycode = MOUSE_RELATIVE_Y;
                        break;
                case REL_WHEEL:
                        event_keycode = MOUSE_RELATIVE_WHEEL;
                        break;
                case REL_HWHEEL:
                        event_keycode = MOUSE_RELATIVE_HWHEEL;
                        break;
                }
        } else if(type == EV_KEY){
                switch (code) {
                case BTN_LEFT:
                        event_keycode = MOUSE_BUTTON_LEFT;
                        break;
                case BTN_RIGHT:
                        event_keycode = MOUSE_BUTTON_RIGHT;
                        break;
                case BTN_MIDDLE:
                        event_keycode = MOUSE_BUTTON_MIDDLE;
                        break;
                }
        }
        return event_keycode;
}

int esm_register(pid_t pid, __u16 type, __u16 code, __user event_handler_t event_handler_user) {
	//If event_handler == NULL
	//	delete application_list[event][application]
	//else
	//	application_list[event][application] = event_handler
	application_l *application_category, *application;
	struct list_head *pos, *q;
	struct task_struct* task;
	esm_event_t event_keycode;
//	struct input_value* event;
//	event->type = type;
//	event->code = code;
	event_handler_t event_handler = event_handler_user;
//	int copy_err = copy_from_user(event_handler, event_handler_user, sizeof(event_handler_t));
//	if(copy_err){
//		printk(KERN_ERR "esm_register could not copy event_handler pointer to kernel space, did not copy %d bytes\n", copy_err);
//		return -EINVAL;
//	}


//	task = pid_task(find_vpid(pid), PIDTYPE_PID);
//	printk(KERN_DEBUG "esm_register: %d\n", pid);
//	task = find_task_by_vpid(pid);
	task = current;
	printk(KERN_WARNING "esm_register: %d\n", task->pid);

	if(task == NULL){
		pr_err("Can not esm_register, task is NULL\n");
		return -EINVAL;
	}

//	event_keycode = esm_keycode_from_input(event);
	event_keycode = esm_keycode_from_input(type, code);
	if(event_keycode == APPLICATION_LIST_SIZE){
		pr_err("Invalid event to register\n");
		return -EINVAL;
	}

	application_category = handlers_for_event(event_keycode);
	if(event_handler == NULL){
		list_for_each_safe(pos, q, &(application_category->list)){
			application = list_entry(pos, application_l, list);
			if(application->event_handler == event_handler){
				list_del(pos);
			}
			kfree(application);
		}
		//free application_list[input_value][task->pid];
	}else{
		//application_list[input_value][task->pid] = event_handler;
		application = kmalloc(sizeof(application_l*), GFP_KERNEL);

		application->event_keycode = event_keycode;
		application->task = task;
		application->event_handler = event_handler;

		//Add application (event_handler) to corresponding application list (list of categorized event handlers)
		list_add(&(application->list), &(application_category->list));
	}
	return 0;
}

int esm_register1(pid_t pid, __u16 type, __u16 code, __user event_handler_t event_handler) {
	return esm_register(pid, type, code, event_handler);
}

int esm_dispatch(struct input_value* event, struct task_struct* task){
	//If task->state == TASK_EV_WAIT
	//	task->state = TASK_RUNNUNG
	//	handler = application_list[event][application]
	//	handler(event)
	//else
	//	application.enqueue(event);
	int dbg_pid = task->pid;
	printk(KERN_WARNING "esm_dispatch pid: %d\n", dbg_pid);

	if(task->state == TASK_EV_WAIT){
		struct list_head* pos;
		application_l *application, *application_category;

//		esm_event_t ev_keycode = esm_keycode_from_input(event);
		esm_event_t ev_keycode = esm_keycode_from_input(event->type, event->code);
		if(ev_keycode == APPLICATION_LIST_SIZE){
			pr_err("Invalid event to dispatch\n");
			return -EINVAL;
		}

		application_category = handlers_for_event(ev_keycode);
		list_for_each(pos, &(application_category->list)){
			application = list_entry(pos, application_l, list);
			if(application->task->pid == dbg_pid){
//				set_task_state(application->task, TASK_RUNNING);
//				set_task_state(task, TASK_RUNNING);

//				if(wake_up_process(task) == 1){
				if(wake_up_state(task, TASK_EV_WAIT) == 1){				//Less overhead to directly assign task-state = TASK_RUNNING
//					application->event_handler(event);
					application->event_handler(event->type, event->code, event->value);
				}else{
					pr_err("Dispatch can not wake up process %d, already running\n", dbg_pid);
				}
				break;
			}
		}
	} else {
		struct event_queue_t* event_queue_item;
		event_queue_item = kmalloc(sizeof(struct event_queue_t*), GFP_KERNEL);
		event_queue_item->event = event;
		list_add(&(event_queue_item->event_queue), &(task->event_queue));
	}
	return 0;
}

int esm_wait(pid_t pid){
//	if(task->event_queue.empty()){
//		task->state = TASK_EV_WAIT;
//	} else {
//		event = task->event_queue.pop();
//		task->state = TASK_EV_WAIT;
//		esm_dispatch(event, task);
//	}

	struct list_head *pos, *q;
	struct event_queue_t* ev_queue;
	struct input_value* event;
	struct task_struct* task;
	int err = 0;

	printk(KERN_WARNING "esm_wait: %d\n", pid);
//        task = find_task_by_vpid(pid);
        task = current;
        if(task == NULL){
                pr_err("Can not esm_wait, task is NULL\n");
		return -EINVAL;
        }

	set_task_state(task, TASK_EV_WAIT);
	if(list_empty(&(task->event_queue))){
		printk(KERN_WARNING "esm_wait: event_queue is empty, scheduling task\n");
		schedule();
//		err = 1;
	}else{
		list_for_each_safe(pos, q, &(task->event_queue)){
			printk(KERN_WARNING "esm_wait: event_queue is not empty, scheduling event\n");
			ev_queue = list_entry(pos, struct event_queue_t, event_queue);
			event = ev_queue->event;
			err = esm_dispatch(event, task);
			list_del(pos);
			kfree(ev_queue);
//			err = 2;
		}
	}
	return err;
}

int esm_wait1(pid_t pid){
	return esm_wait(pid);
}


int esm_interpret(struct input_value* event){
	//foreach application in application_list
	//	esm_dispatch(event, application)
	struct list_head* pos;
	struct task_struct* task;
	application_l *application, *application_category;
	esm_event_t ev_keycode;
	int err = 0;

	printk(KERN_WARNING "Call to ESM Interpret\n");
//	pr_debug("Call to ESM Interpret\n");

//	ev_keycode = esm_keycode_from_input(event);
	ev_keycode = esm_keycode_from_input(event->type, event->code);
	if(ev_keycode == APPLICATION_LIST_SIZE){
		pr_err("Invalid event being interpreted\n");
		return -EINVAL;
	}

	application_category = handlers_for_event(ev_keycode);
	list_for_each(pos, &(application_category->list)){
		application = list_entry(pos, application_l, list);
		task = application->task;
		err = esm_dispatch(event, task);
	}
	return err;
}



//asmlinkage long sys_esm_register(pid_t pid, __u16 type, __u16 code, event_handler_t event_handler) {
//	struct input_value event;
//	event.type = type;
//	event.code = code;
//
//	return esm_register(pid, event, event_handler);
//}

//asmlinkage long sys_esm_wait(pid_t pid) {
//	return esm_wait(pid);
//}

//typedef void (*event_handler_t)(__u16, __u16, __s32);
//SYSCALL_DEFINE4(esm_register, pid_t, pid, __u16, type, __u16, code, event_handler_t, event_handler){
//	return esm_register(pid, event, event_handler);
//}
//SYSCALL_DEFINE1(esm_wait, pid_t, pid){
//	return esm_wait(pid);
//}

